<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vite 从入门到删库跑路🤡 | Big Rice 🍚</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Vite 是与 Webpack 具有同样用途的前端构建工具，但它更快，更强">
    
    <link rel="preload" href="/bigRiceRice.io/dist/assets/css/0.styles.ab9b956a.css" as="style"><link rel="preload" href="/bigRiceRice.io/dist/assets/js/app.85c1285e.js" as="script"><link rel="preload" href="/bigRiceRice.io/dist/assets/js/6.4adeed80.js" as="script"><link rel="preload" href="/bigRiceRice.io/dist/assets/js/12.568a4166.js" as="script"><link rel="preload" href="/bigRiceRice.io/dist/assets/js/91.757cf1df.js" as="script"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/10.5590a827.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/11.168de83c.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/13.e940090d.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/14.dc0bcdc3.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/15.d1d3e4db.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/16.588f5b28.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/17.b1d8cb07.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/18.f866ec42.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/19.494e290e.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/20.3d3ce014.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/21.6c57ba8e.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/22.9897e082.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/23.7a860a2e.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/24.471429ef.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/25.3a1e5f8f.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/26.0508ee1a.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/27.194ce927.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/28.ea5c86d6.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/29.0226dfe3.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/3.2a259be5.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/30.53e58f2b.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/31.73b312ac.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/32.ce9b6eaa.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/33.1e9cab45.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/34.94a6a205.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/35.e69c119d.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/36.567f1f05.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/37.3ad6ab5d.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/38.be899865.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/39.10be43b8.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/4.cb5dc486.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/40.8107d5e5.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/41.ac71460e.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/42.79541116.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/43.26376eac.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/44.3284b01f.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/45.5820e486.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/46.2c134927.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/47.fa57f3e9.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/48.4f57b88a.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/49.1b521d59.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/5.44ec780a.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/50.ad5e5ae9.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/51.870855b2.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/52.9cf1cb74.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/53.d4b795ae.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/54.1272cce0.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/55.5046e0eb.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/56.6d6b64d7.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/57.362e237b.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/58.ba742252.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/59.4c13ca5c.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/60.dd86caec.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/61.6456d5a0.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/62.67734952.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/63.4e58faa1.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/64.f874beec.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/65.b0bf52e7.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/66.912efc81.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/67.24ba54c4.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/68.471581d3.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/69.87a1fc99.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/7.a918f9c2.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/70.d6112df9.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/71.58db827b.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/72.1836b740.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/73.076e80b8.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/74.521367cc.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/75.b029f72e.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/76.e37d92f0.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/77.a79060a6.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/78.7770cad6.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/79.bc097473.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/8.222ede8f.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/80.f63d521a.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/81.365cad89.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/82.9aea664c.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/83.cf664abd.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/84.dc82b241.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/85.1ffe4b08.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/86.17adc80c.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/87.df067883.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/88.afeafe63.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/89.d49c5fb6.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/9.b604d7b7.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/90.184ba86d.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/92.64a7dd78.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/93.1d6d4e31.js"><link rel="prefetch" href="/bigRiceRice.io/dist/assets/js/vuejs-paginate.bd98283b.js">
    <link rel="stylesheet" href="/bigRiceRice.io/dist/assets/css/0.styles.ab9b956a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/bigRiceRice.io/dist/" class="nav-link home-link">Big Rice 🍚 </a> <button class="back" style="display:;">↩</button></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/bigRiceRice.io/dist/FrameWork/" class="nav-link">框架</a></li><li class="nav-item"><a href="/bigRiceRice.io/dist/Css/" class="nav-link">Css</a></li><li class="nav-item"><a href="/bigRiceRice.io/dist/API/" class="nav-link">API</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/bigRiceRice.io/dist/" class="nav-link mobile-home-link">Big Rice 🍚 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/bigRiceRice.io/dist/FrameWork/" class="nav-link">框架</a></li><li class="mobile-nav-item"><a href="/bigRiceRice.io/dist/Css/" class="nav-link">Css</a></li><li class="mobile-nav-item"><a href="/bigRiceRice.io/dist/API/" class="nav-link">API</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div><div class="content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>JS 这门语言，在设计之处就没有模块体系，所以他会经历模块化演变，直到2015年，TC39（一群浏览器厂商代表组成的委员会）发布了ES6 规范，ES Modules 才被世人所知，也就是ESM。而在模块化演变过程中，模块化本身暴露的问题也越来越明显。</p> <p>项目中的模块越来越多，在管理上造成了混乱，所以迫切需要一些工具解决各种模块类型混乱的问题。Webpack 和 Vite等工具就是用来解决这些问题的。</p> <h2 id="关于-vite"><a href="#关于-vite" class="header-anchor">#</a> 关于 <em>Vite</em></h2> <blockquote><p>Vite（法语意为 &quot;快速的&quot;，发音 <code>/vit/</code>，发音同 &quot;veet&quot;）是一种新型前端构建工具，能够显著提升前端开发体验。</p></blockquote> <p>通俗的来讲，Vite 是与 Webpack 具有同样用途的<strong>前端构建工具</strong>（打包，热更新...）。</p> <h3 id="什么是构建工具"><a href="#什么是构建工具" class="header-anchor">#</a> 什么是构建工具</h3> <p>假设企业需要开发一个成熟的前端项目，那么大概率会运用到以下技术栈：</p> <ul><li><code>Vue &amp; React</code></li> <li><code>Typescript</code></li> <li><code>Less &amp; Scss</code></li> <li>各种新技术......</li></ul> <p>可惜浏览器并不认识 <code>vue &amp; jsx &amp; tsx</code> 这些后缀的文件，只能通过解析工具将其转换浏览器能够识别的 <code>js</code> 文件。</p> <p>那么我写好一个 <code>ts</code> 文件，想要在浏览器正常运行，就必须通过 <code>tsc</code> 命令将其转换为 <code>js</code> 文件，这很简单😉，不是吗。</p> <p>但如果写的是 <code>tsx</code> 文件呢？我们就得做以下<strong>三</strong>步转换：</p> <ol><li>先转换为 <code>jsx</code> 文件</li> <li>再转换为 <code>render</code> 函数</li> <li>再封装为 <code>js</code> 文件</li></ol> <p>如果每一次保存都需要执行以上流程来转换，那么你将拥有<strong>极其糟糕</strong>的开发体验🙄。</p> <p>这个时候我们需要一样东西，它可以<strong>自动</strong>的帮我们执行以上流程，这个东西就是<strong>前端构建工具</strong>，目前主流的构建工具有：</p> <ol><li><em>Webpack</em></li> <li><em>Vite</em></li> <li><em>esbuild</em></li> <li><em>rollup</em></li> <li>......</li></ol> <p>如果前端构建工具只有代码转换的话，那就太逊辣，其实构建工具还能完成以下工作：</p> <ul><li>模块化兼容：支持<strong>各种</strong>规范的模块化开发，导入 &amp; 导出</li> <li>代码兼容性：使用 <em>Babel</em> 等工具完成 less &amp; Scss &amp; Vue &amp; Jsx 等文件的<strong>语法降级</strong> &amp; <strong>代码兼容</strong> <ul><li>注意：代码兼容性不是构建工具完成的，而是内置的 Babel 等工具完成的</li></ul></li> <li>提升项目性能：压缩文件大小（<em>Tree Shaking</em>），<strong>代码分割</strong>等功能</li> <li>优化开发体验
<ul><li>开启一个本地开发服务器，解决<strong>跨域问题</strong></li> <li>自动监听文件变化，自动调用工具打包，自动热重启服务器，这个过程就是<strong>热更新</strong>（<em>Hot replacement</em>）</li></ul></li></ul> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <p>构建工具可以<strong>减少我们开发时的心智负担，优化开发效率</strong>。</p> <p>我们不需要考虑使用框架构建项目的代码如何才能运行到浏览器这种问题，只需要设置构建工具的配置文件即可让构建工具自动工作（<code>webpack.congif.js</code> &amp; <code>Vite.config.js</code>）</p> <h3 id="相较于-webpack-的优势"><a href="#相较于-webpack-的优势" class="header-anchor">#</a> 相较于 <em>Webpack</em> 的优势</h3> <p>其实 <em>Vite</em> 的优势在<a href="https://Vitejs.cn/Vite3-cn/" target="_blank" rel="noopener noreferrer">官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>就提到过：</p> <blockquote><p>然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到<strong>性能瓶颈</strong>：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。</p></blockquote> <p>上面提到的<strong>性能瓶颈</strong>指的就是 <em>Webpack</em>，那么 <em>Webpack</em> 为啥会有性能瓶颈呢？这不得不从 <em>Webpack</em> 的打包过程说起：</p> <blockquote><p>Webpack 打包流程图</p></blockquote> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301201752735.jpeg" alt="webpackFlowChart"></p> <p>首先我们要知道 Webpack 是<strong>支持多种模块化</strong>（<em>CommonJS &amp; ESM</em>），这意味着 Webpack 必须在兼容性上下工具，且早期的 Webpack 起家的时候 ESM 规范并没有落地，导致了存在性能瓶颈问题（底层原理能说改就改吗）。</p> <p>Webpack 的打包流程大致如下：</p> <ol><li>通过 <code>AST</code> 抽象语法递归分析入口文件引用了哪些那些文件，随后将不同的规范转换为 Webpack 规范，并创建好文件依赖</li> <li>根据文件依赖将所有文件<strong>打包</strong></li> <li>完成服务器启动</li></ol> <p>热更新问题：</p> <ul><li>以当前修改的文件为入口重新打包，所有涉及到的依赖也都会被重新加载一次😱</li></ul> <p>假设是小项目还好，等待时间不需要太久，但如果是非常大的项目的话，打包需要等待的时间将随着项目大小<strong>呈指数级上升</strong>，所以体验非常糟糕。</p> <blockquote><p>可以想象一下，假设一个超级大的项目出现了 bug，你开启了 Webpack 的热更新尝试修改 bug ，但你每次一保存触发热更新都要等上几分钟或者十几分钟，体验将是多么糟糕😫。</p></blockquote> <p>那么 Vite 会有这种情况吗😟？</p> <p>答案是<strong>不  会！👌</strong></p> <p>vite 法语意为“ <em>快速</em> ”，如果它存在这种性能问题岂不是自砸招牌？它的解决方式非常巧妙，甚至可以称得上是~~<strong>狡猾</strong>~~🤙。</p> <blockquote><p>Vite 打包流程图</p></blockquote> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301201809764.png" alt="ViteFlowChart"></p> <p>首先我们要知道，Vite 背靠 <em>ESM</em> 规范为基础来完成打包，它的打包流程大致如下：</p> <ol><li><strong>直接启动</strong>一台静态页面的服务器，<strong>不打包</strong>文件代码</li> <li>服务器会根据客户端的请求加载不同的模块处理，实现真正的<strong>按需加载</strong></li></ol> <p>热更新问题：</p> <ul><li>采用立即编译当前修改文件的办法，同时使用缓存机制
<ul><li>Vite 会将所有依赖文件打包一份放到 <code>node_moduels/.Vite/deps/</code> 下</li></ul></li></ul> <blockquote><p>跟 Webpack 反着来</p></blockquote> <p>所以，Vite 具有了<strong>快速冷启动、按需编译、模块热更新</strong>等优良特质</p> <h4 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h4> <p>Webpack 与 Vite 本质上的区别就在于「 <strong>按需加载</strong> 」。</p> <p>Webpack 无论怎么提倡按需加载，哪怕底层完成了 <em>Webpack_Require</em> ，在 ESM 面前都是<strong>假的按需加载</strong>。</p> <p>因为在 ESM 之前浏览器并不支持模块化，而 ESM 的诞生，<strong>标志着 Js 有了自己的模块体系</strong>。</p> <p>所以 Vite 的<strong>快</strong>一大步部分是基于 ESM 规范落地产生的红利。</p> <p>&amp;Q：那么 <strong>Vite 会取代 Webpack吗</strong></p> <p>&amp;A：不会，vite 的发展才刚刚起步，而浏览器的多样性也导致 ESM 规范落地没有那么快。webpack 的社区、生态已经非常完善，这不是 vite 一个刚出生的小孩可以媲美的，但是 vite 的未来是一定会比 webpack 更加强大，这是科技发展所必然经历的，一代更比一代强。</p> <h3 id="你必须了解的-vite-与-create-vite-的区别"><a href="#你必须了解的-vite-与-create-vite-的区别" class="header-anchor">#</a> 你必须了解的 <em>Vite</em> 与 <em>create-vite</em> 的区别</h3> <p>如果你有过 Vite 项目的开发经验，那么你一定敲过这串命令：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">npm</span> create vite
</code></pre></div><p>你可能会以为是 Vite 构建工具帮我们创建了一个 Vite 项目，但其实不然，Vite 它只是一个构建工具，它不应该把类似 <em>vue-cli &amp; create-react-app</em> 这类脚手架应该做的事做到。</p> <p>其实这串指令会帮我们安装一个东西，叫做 <em>create-vite</em> （Vite 项目的脚手架），并运行 <code>bin</code> 目录下的某个执行配置。</p> <p>那么 create-vite 与 Vite 的关系是什么？</p> <ul><li>create-vite 中内置了 Vite，就像 vue-cli &amp; create-react-app 中内置了 Webpack 一样。</li></ul> <h2 id="初体验"><a href="#初体验" class="header-anchor">#</a> 初体验</h2> <p>Vite 是<strong>开箱即用</strong>（<em>out of box</em>）的，我们不需要做任何额外的配置即可使用 Vite 帮我们处理一些工作：</p> <ul><li>比如<strong>模块化支持 &amp; 兼容</strong>。</li></ul> <p>何为<strong>模块化支持</strong>？一个最简单的效果就是 Vite 会自动补全我们在 <code>html</code> 中引入的模块路径，让我们来看下面的例子：</p> <p>首先我们创建一个 <em>Demo</em> 目录，并初始化项目，随后添加一个 <em>lodash</em> 包：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">mkdir</span> Demo 
<span class="token builtin class-name">cd</span> .<span class="token punctuation">\</span>Demo<span class="token punctuation">\</span>
<span class="token function">yarn</span> init <span class="token parameter variable">-y</span>
<span class="token function">yarn</span> <span class="token function">add</span> lodash
</code></pre></div><p>这是目录最后的结构：</p> <div class="language- extra-class"><pre class="language-text"><code>Demo
|-- node_modules
|-- index.html
|-- src
|   └-- main.js
|-- package.json
|-- yarn.lock
</code></pre></div><p>这是 html 结构：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>X-UA-Compatible<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>IE=edge<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 使用 ESM 模块化语法导入一个 js 文件 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./src/main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这是 main.js 代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.js</span>
<span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">'lodash'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span>
</code></pre></div><p>如果我们在 index.html 中通过 <em>Live Server</em> 打开服务器，控制台将会抛出一个错误信息：</p> <div class="language- extra-class"><pre class="language-text"><code>Uncaught TypeError: Failed to resolve module specifier &quot;lodash&quot;. Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.
</code></pre></div><p>这是因为在 <em>ESM</em> 规范中导入包只能通过 <code>/</code>、<code>./</code>、<code>../</code> 等方式来导入，且不会自动补全 <em>/node_modules/</em> 目录字段，所以就找不到文件，从而引发报错。</p> <blockquote><p>ESM 设计成这样是有原因的，假设支持了路径自动补全，将会引发一个问题，即<strong>网络多包性能问题</strong>：</p> <ul><li>假设引入指定的包中又依赖了更多的包，那么将会发起非常多的 HTTP 请求，这可能会将造成 JS 线程堵塞，进而影响性能。</li></ul></blockquote> <p>那么我们自己将路径补全，还会不会报错呢？</p> <p>让我们将 main.js 改造成这样如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.js</span>
<span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">&quot;./node_modules/lodash/index.js&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span>
</code></pre></div><p>打开浏览器查看，很不幸，还是会报错😣，且报错内容如下：</p> <div class="language- extra-class"><pre class="language-text"><code>Uncaught SyntaxError: The requested module './node_modules/lodash/index.js' does not provide an export named 'default'
</code></pre></div><p>解释一下就是该 js 文件并没有按照 ESM 规范使用 <code>exprot</code> 等语法导出（浏览器只支持 ESM 规范），所以浏览器是不支持导入该文件的。</p> <p>那么这个时候，该 Vite 上场表演了！😎</p> <p>首先安装 Vite：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> vite
</code></pre></div><p>并将 main.js 恢复原样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.js</span>
<span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">'lodash'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span>
</code></pre></div><p>随后使用 <code>npx vite</code> 开启服务器（vite 会自动读取根目录的 index.html 作为 entry 入口文件）</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301202107469.png" alt="image-20230120210733411"></p> <p>打开浏览器查看控制台，可以看到 main.js 正常导入了 lodash 工具包，大功告成了！</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301202108902.png" alt="image-20230120210843859"></p> <p>这就是 Vite 的<strong>模块化支持</strong>自动帮我们处理了<strong>路径问题</strong>，也是 Vite 所声称的<strong>开箱即用</strong>。</p> <p>但如果你足够细心，查看了一下网络请求，那么细心的你会看到 lodash 请求的地址其实不是原来的 lodash 源文件地址（本来应该是 lodash/index.js）：</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301202142849.png" alt="image-20230120214208785"></p> <h2 id="关于依赖预构建"><a href="#关于依赖预构建" class="header-anchor">#</a> 关于依赖预构建</h2> <h3 id="前言-2"><a href="#前言-2" class="header-anchor">#</a> 前言</h3> <p>开始了解依赖预构建之前，我们首先需要明白依赖预构建的<strong>动机</strong>，或者说它的存在是为了解决哪些问题。</p> <p>我们回到 Vite 初体验中的例子，查看一下 lodash/index.js 文件中的模块化导出规范是那种：</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301202144812.png" alt="image-20230120214438770"></p> <p>当我们看到 <code>module.exports</code> 的时候不难猜出 <code>lodash</code> 的模块化导出规范使用的是 <em>CommonJS</em></p> <p>再查看一下预构建后的请求地址（即 <em>/node_modules/.vite/deps/</em>）中的 lodash 文件内容</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301202207498.png" alt="image-20230120220708441"></p> <p>可以看到，Vite 将其他规范中的导出文件夹经过封装后导出了一个 ESM 规范的文件。</p> <p>这就是依赖预构建解决的问题之一：</p> <ul><li>不同模块化规范之间的处理 ——&gt; 统一为 ESM 规范</li></ul> <h3 id="什么是依赖预构建呢"><a href="#什么是依赖预构建呢" class="header-anchor">#</a> 什么是依赖预构建呢？</h3> <p>依赖预构建就是 Vite 会在打包的时候，先找到依赖文件，随后调用 esbuild（将其他规范转换为 ESM 规范）完成规范统一，后在当前根目录下的 <em>/node_modules/.vite/deps/</em> 中将转换后的文件写入，这一个过程就被称作“依赖预构建”。</p> <p><strong>依赖预构建主要解决了 3 个问题：</strong></p> <ol><li>不同模块化规范之间的兼容问题
<ul><li>调用 esbuild 解决</li></ul></li> <li>路径处理问题
<ul><li>将所有依赖文件全部封装进 <em>.vite/deps/</em> 下，方便热更新读取</li></ul></li> <li>网络多包性能问题
<ul><li>对依赖文件的封装进而达到简化 HTTP 请求的次数，因为<strong>多包</strong>已经被集成变为了<strong>单包</strong></li></ul></li></ol> <h4 id="简单看下网络多包性能问题"><a href="#简单看下网络多包性能问题" class="header-anchor">#</a> 简单看下网络多包性能问题</h4> <p>我们可以配置手动复现网络多包性能问题，从而进一步了解依赖预构建的强大👊。</p> <p>首先添加 <em>lodash-es</em> 包：</p> <blockquote><p>该包为 lodash 的 ESM 规范版，假如直接引入，会将所有工具函数作为 ESM 规范引入</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> loadsh-es
</code></pre></div><p>在 Vite 项目中引入 <em>lodash-es</em> ：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// main.js</span>
<span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">&quot;lodash-es&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意：添加如下 Vite 配置，忽略依赖预构建</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vite.config.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
    <span class="token comment">// 依赖yu</span>
    <span class="token literal-property property">optimizeDeps</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token comment">// 排除数组中的包</span>
        <span class="token literal-property property">exclude</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;lodash-es&quot;</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>打开服务器，测试一下你的网速有多快 : )</p> <img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301202314927.gif" alt="demo" style="zoom:67%;"> <p>可以看到，直接请求了 600+ 的包</p> <p>开启依赖预构建的效果如下：</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301202316283.png" alt="image-20230120231659227"></p> <h2 id="配置文件细节处理"><a href="#配置文件细节处理" class="header-anchor">#</a> 配置文件细节处理</h2> <h3 id="语法补全"><a href="#语法补全" class="header-anchor">#</a> 语法补全</h3> <ol><li><p>如果使用的是 WebStorm，那么你将得到很好的语法补全</p></li> <li><p>如果使用的是 VS Code，那么需要如下配置才能获得语法补全：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vite.config.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vite&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">optimizeDeps</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;lodash-es&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// ——————————————————————————————————</span>
<span class="token comment">/** @type import(&quot;vite&quot;).UserConfig */</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">optimizeDeps</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">exclude</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;lodash-es&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h2 id="关于环境处理"><a href="#关于环境处理" class="header-anchor">#</a> 关于环境处理</h2> <p>在 Webpack 中，根据不同环境的不同处理需要定义多个配置文件，所以一个 Webpack 项目根目录下大概率会出现多个配置文件：</p> <ol><li><em>webpack.config.js</em>：<strong>默认</strong>配置文件，只有该文件被<strong>默认调用</strong>的。</li> <li><em>webpack.<strong>dev</strong>.config.js</em>：开发环境下配置文件，语义化的自定义配置文件。</li> <li><em>webpack.<strong>prod</strong>.config.js</em>：生产环境下配置文件，语义化的自定义配置文件。</li> <li><em>webpack.<strong>base</strong>.config.js</em>：任何环境下的基础配置文件，语义化的自定义配置文件。</li> <li><em>webpack.xxx.config.js</em> ......</li></ol> <p>这些奇奇怪怪的配置文件都是为了将环境区分开来从而在不同环境下执行不同的配置，所以 <em>package.json</em> 中也需要配置多条命令，或使用不同的处理来完成。</p> <p>而在 Vite 中，我们可以避免定义多个配置文件与定义不同环境下的调用命令，因为 <code>defindeConfig</code> 会默认暴露环境模式参数（<code>mode</code>），我们可以通过判断 <code>mode</code> 的取值来自动执行相应环境下的配置文件，来看下面的例子：</p> <p>首先定义一个 <em>vite-configs</em> 目录，并创建多个配置文件，目录结构如下：</p> <div class="language- extra-class"><pre class="language-text"><code>vite-configs
|-- base.js # 基础的配置文件
|-- prod.js # 生产环境下的配置文件
|-- dev.js  # 开发环境下的配置文件
</code></pre></div><p>vite.config.js 代码如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  vite.config.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vite&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> base <span class="token keyword">from</span> <span class="token string">&quot;./vite-configs/base.js&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> prod <span class="token keyword">from</span> <span class="token string">&quot;./vite-configs/prod.js&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> dev <span class="token keyword">from</span> <span class="token string">&quot;./vite-configs/dev.js&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> environments <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">production</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">调用生产环境下的配置文件</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>base<span class="token punctuation">,</span> <span class="token operator">...</span>prod <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">development</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">调用开发环境下的配置文件</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token operator">...</span>base<span class="token punctuation">,</span> <span class="token operator">...</span>dev <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>mode<span class="token punctuation">,</span> command<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// mode    为开发环境，取值有: `production` &amp; `development`</span>
    <span class="token comment">// command 为命令环境，取值有: `serve`      &amp; `build`</span>
    <span class="token keyword">return</span> environments<span class="token punctuation">[</span>mode<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这样我们就完成了根据环境自动调用不同的配置文件，让我们调用看看效果吧。</p> <p>执行 <code>npx vite</code>：</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301211124239.png" alt="image-20230121112435168"></p> <p>执行 <code>npx vite build</code> ：</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301211125134.png" alt="image-20230121112519085"></p> <h2 id="关于环境变量"><a href="#关于环境变量" class="header-anchor">#</a> 关于环境变量</h2> <p>环境变量即根据当前代码环境的不同而变化的某个值，举个最简单的需求吧，</p> <ul><li>项目在 development 开发环境中的标题为 “ <em>项目开发中</em> ”，</li> <li>项目在 production 生产环境中的标题为 “ <em>项目已上线</em> ”。</li></ul> <p>那么就可以将这个值称为<strong>环境变量</strong>。</p> <blockquote><p>让我们开始实现需求，先了解一些东西。</p></blockquote> <p>首先一个成熟的项目或许有以下几种环境：</p> <ul><li>开发环境</li> <li>测试环境</li> <li>预发布环境</li> <li>灰度测试环境</li> <li>线上环境</li></ul> <p>那么如何管理这么多环境中的环境变量呢？</p> <ul><li><p>Vite 环境变量上的处理使用的是一个叫做 <em>dotenv</em> 的第三方库，默认情况下，dotenv 会读取当前工程根目录（调用 <code>yarn dev</code> 时的根目录）的一个叫做 <code>.env</code> 的文件（该文件存放的即是全局的环境变量），并<strong>在最后</strong>将它挂载到 <code>process.env</code> 属性中供服务器使用。</p> <blockquote><p><em>process</em> 是 Node 中的一个对象，该对象代表着当前<strong>进程</strong>，<em>process.env</em> 则代表着当前进程的环境变量</p></blockquote></li></ul> <p>接下来让我们来尝试实现之前说的的需求，在根目录下创建一个 <em>.env</em> 文件并写入一个 <strong>VITE_TITLE</strong> 环境变量：</p> <blockquote><p>这里顺便说一嘴，VITE 中使用环境变量的定义也是有约定的：</p> <ul><li><p>默认情况下只有以 “<strong>VITE_</strong>” 开头的变量才会在客户端被捕获，访问方式为：<code>import.meta.env.{参数名}</code></p></li> <li><p>所有值都是字符串</p></li> <li><p>对于 true / false 的值，拿到的只能是 'true' / 'false '，并不是 boolean 值，不能直接使用，需要判断 xxx === 'true'。</p></li></ul></blockquote> <div class="language- extra-class"><pre class="language-text"><code># .env
VITE_TITLE = 默认标题
</code></pre></div><p>并在配置文件中打印 <code>process.env</code> 查看是否环境变量是否正常挂载：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vite&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> mode <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;process.env&quot;</span><span class="token punctuation">,</span> process<span class="token punctuation">.</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>很可惜，<code>process.env</code> 上是找不到 <code>VITE_TITLE</code> 这个属性的，并不是 dotenv 没有工作，而是 Vite 出于更多的考虑而有意为之的 。这其中的原因是涉及到了 Vite 两个关于环境变量的配置项：</p> <ol><li><em>root</em></li> <li><em>envDir</em>：用于配置环境变量的地址</li></ol> <blockquote><p>因为有了两个配置项的存在，我们一开时读取的 <code>process.env</code> 并没有被直接修改，因为后续的配置项可能会影响到它（也可以理解为读取<strong>早了</strong>）。</p></blockquote> <p>其实说回来 <code>process.env</code> 对我们开发用处不大，因为 Vite 客户端用不到这些参数，且 Vite 向客户端暴露的环境变量是通过 <code>import.meta.env</code> 来访问的，所以我们不需要管 <code>process.env</code>，只需要了解就好了。</p> <h3 id="import-meta-env"><a href="#import-meta-env" class="header-anchor">#</a> <em>import.meta.env</em></h3> <blockquote><p><em>import.meta.env</em> 默认只有 5 个属性：</p> <ul><li><strong>BASE_URL</strong>：当前的 URL，取值为字符串</li> <li><strong>DEV</strong>：当前是否为开发环境，取值为 true &amp; false</li> <li><strong>MODE</strong>：当前的环境，取值为 development &amp; production</li> <li><strong>PROD</strong>：当前是否为生产环境，取值为 true &amp; false</li> <li><strong>SSR</strong>：当前是否为 SSR 服务器渲染，取值为 true &amp; false</li> <li>以 <strong>VITE_</strong> 开头的环境变量......</li></ul></blockquote> <p>那么如何将环境变量添加至 <code>import.meta.env</code> 供客户端访问呢？</p> <p>Vite 提供了一个方法，就是 <code>loadEnv()</code> API，我们可以调用它来手动确认环境变量文件的位置，并根据配置单独获取环境变量，随后获取的环境变量将添加至  <code>import.meta.env</code> 中，最后返回匹配到的环境变量对象。</p> <blockquote><p><em><strong>loadEnv 的语法</strong></em></p> <div class="language-ts extra-class"><pre class="language-ts"><code> <span class="token function">loadEnv</span><span class="token punctuation">(</span>mode<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> envDir<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> prefixes<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;</span>
</code></pre></div><ul><li><code>mode</code>：必需，当前的环境模式（development &amp; production 或其它）</li> <li><code>envDir</code>：必需，当前环境变量文件的根目录</li> <li><code>prefixes</code>：可选，接受的环境变量前缀，默认为 <code>VITE_</code> <ul><li>若传入 &quot;&quot;，则表示加载所有环境变量文件中的<strong>所有环境变量</strong></li></ul></li></ul></blockquote> <p>让我们承接上文，使用 loadEnv 帮我们找到丢失的 <code>VITE_TITLE</code>。</p> <p>修改 <em>vite.config.js</em> ：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig<span class="token punctuation">,</span> loadEnv <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vite&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> mode <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> env <span class="token operator">=</span> <span class="token function">loadEnv</span><span class="token punctuation">(</span>mode<span class="token punctuation">,</span> process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;env&quot;</span><span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>关于 <code>process.cwd()</code>：</p> <ul><li>返回的是一个路径字符串，路径的取值是调用 <code>yarn dev</code> 时处于的<strong>工程根目录</strong>。</li></ul></blockquote> <p>查看打印结果：</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301211545692.png" alt="image-20230121154551620"></p> <p>可以看到已经成功读取到 <code>VITE_TITLE</code> 了😁。</p> <p>那么我们如何定义不同环境的环境变量文件供 loadEnv 读取呢？Vite 中只有以下环境变量文件名才能根据 <code>mode</code> 被自动读取 ：</p> <ul><li><em>.env</em>：<strong>全局</strong>的环境变量文件，总是会被读取。</li> <li><em>.env.<strong>development</strong></em>：开发环境下自动读取的环境变量文件，将覆盖 <em>.env</em> 中重复的变量。
<ul><li><strong>缩写</strong>为 <em>.env.dev</em> 是<strong>不会自动读取</strong>的。</li></ul></li> <li><em>.env.<strong>production</strong></em>：生产环境下自动读取的环境变量文件，将覆盖 <em>.env</em> 中重复的变量。
<ul><li><strong>缩写</strong>为 <em>.env.prod</em> 是<strong>不会自动读取</strong>的。</li></ul></li> <li><em>.env.xxx</em>：自定义的环境变量文件，若需要读取自定义，那么 <em>mode</em> 模式也要为自定义。
<ul><li>可通过修改 <code>yarn dev --mode xxx</code> 的方式保持自动读取，因为 loadEnv 是根据 mode 读取文件名的😉</li></ul></li></ul> <p>好的，回到最开始的需求，在根目录下定义 <em>.env.development</em> 文件：</p> <div class="language- extra-class"><pre class="language-text"><code># .env.development
VITE_TITLE = 项目开发中
</code></pre></div><p>定义 <em>.env.production</em> 文件：</p> <div class="language- extra-class"><pre class="language-text"><code># .env.production
VITE_TITLE = 项目已上线
</code></pre></div><p>先浅浅的跑一下不同的环境查看变量获取的是否正确吧💅：</p> <p>开发环境下：</p> <img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301211615548.png" alt="image-20230121161500483" style="zoom:67%;"> <p>生产环境下：</p> <img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301211615054.png" alt="image-20230121161549994" style="zoom:67%;"> <p>打印输出正确👌。</p> <p>最后让我们创建一个 html 与 index.html 文件，实现需求吧！</p> <p>这是目录结构：</p> <div class="language- extra-class"><pre class="language-text"><code>|-- node_modules
|-- index.html
|-- main.js
|-- package.json
|-- yarn.lock
</code></pre></div><p>html 文件如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>./main.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>main.js 代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">VITE_TITLE</span><span class="token punctuation">;</span>
</code></pre></div><p>这是 vite.config.js 配置文件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig<span class="token punctuation">,</span> loadEnv <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vite&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> mode<span class="token punctuation">,</span> command <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">loadEnv</span><span class="token punctuation">(</span>mode<span class="token punctuation">,</span> process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>package.json 代码如下：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;index.js&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;license&quot;</span><span class="token operator">:</span> <span class="token string">&quot;MIT&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;dev&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vite --mode development --open&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;prod&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vite --mode production --open&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;vite build&quot;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;vite&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.0.4&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>开启项目查看：</p> <p><img src="https://sbr-1314368469.cos.ap-guangzhou.myqcloud.com/Images/202301211653849.gif" alt="demo"></p> <p>可以看到，需求实现了。</p> <p>那么到这里就可以介绍一个配置项了：</p> <ul><li><em><strong>envPrefix</strong></em>：设置当前环境变量的<strong>取值前缀</strong>，同 loadEnv 中的第三个参数。</li></ul> <p>假如我们项目有这样的规范，开发环境中的环境变量使用 <em>DEV_</em> 前缀开头，生产环境中的环境变量使用 <em>PROD_</em> 前缀开头。</p> <ul><li><p>那么我们就可以在 <em>vite.dev.config</em> 中定义 <code>envPrefix</code> 为 “<strong>DEV_</strong>”。</p></li> <li><p>在 <em>vite.prod.config</em> 中定义 <code>envPrefix</code> 为 “<strong>PROD_</strong>”。</p></li></ul> <h4 id="关于-loadenv-的细节"><a href="#关于-loadenv-的细节" class="header-anchor">#</a> 关于 loadEnv 的细节</h4> <p>当我们调用 loadEnv 后，他会做一下几件事情：</p> <ol><li>直接找到 .env 文件，并解析其中的环境变量，存放到一个对象中</li> <li>将传进来的 <code>mode</code> 值拼接后作为查询的文件，语法为  <code>.env.[mode]</code>，并根据传入的目录查找这个 <code>.env.[mode]</code> 文件存入一个对象</li> <li>最后将两个对象合并</li></ol> <ul><li><p>也可以这样理解：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一步</span>
<span class="token keyword">const</span> baseEnv <span class="token operator">=</span> <span class="token function">findAndParse</span><span class="token punctuation">(</span><span class="token string">'.env'</span><span class="token punctuation">)</span>
<span class="token comment">// 第二步</span>
<span class="token keyword">const</span> modeEnv <span class="token operator">=</span> <span class="token function">findAndParse</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">.env.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token comment">// 第三步 </span>
<span class="token keyword">const</span> env <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>baseEnv<span class="token punctuation">,</span> <span class="token operator">...</span>modeEnv <span class="token punctuation">}</span>
</code></pre></div></li></ul> <p>正是因为 <code>mode</code> 可以影响到获取的文件，这才支持了多种环境变量文件的存在，假如我有一个 <code>.env.test</code> 环境变量文件，那么我要将它添加到 <code>import.meta.env</code> 中，我就要这样启动项目：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">yarn</span> dev <span class="token parameter variable">--mode</span> <span class="token builtin class-name">test</span>
</code></pre></div><h2 id="参考文章-视频"><a href="#参考文章-视频" class="header-anchor">#</a> 参考文章 &amp; 视频</h2> <ul><li><p><a href="https://www.bilibili.com/video/BV1GN4y1M7P5/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8d08e7af2575a84783be5a41708ac09e" target="_blank" rel="noopener noreferrer">Vite世界指南（带你从0到1深入学习 vite）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://www.w3cschool.cn/article/b6e4e9c41df734.html" target="_blank" rel="noopener noreferrer">浏览器、ESM规范、模块化、webpack和vite之间联系？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/bigRiceRice" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8>该网站使用 vuepress + @vuepress/theme-blog 搭建 —— by: Big Rice © 2023</li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/bigRiceRice.io/dist/assets/js/app.85c1285e.js" defer></script><script src="/bigRiceRice.io/dist/assets/js/6.4adeed80.js" defer></script><script src="/bigRiceRice.io/dist/assets/js/12.568a4166.js" defer></script><script src="/bigRiceRice.io/dist/assets/js/91.757cf1df.js" defer></script>
  </body>
</html>
